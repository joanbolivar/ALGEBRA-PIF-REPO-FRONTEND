^\d{5}$;12345;Esta regex busca exactamente cinco dígitos. La cadena '12345' coincide porque contiene cinco dígitos numéricos consecutivos. ^ indica el inicio de la cadena, \d representa cualquier dígito (0-9), {5} especifica que \d debe aparecer exactamente cinco veces, y $ indica el final de la cadena.;^: Inicio de línea, \d: Dígito, {5}: Exactamente 5 veces, $: Fin de línea.
^\d{5}$;1234;Esta regex busca exactamente cinco dígitos. La cadena '1234' no coincide porque solo contiene cuatro dígitos y la regex requiere cinco. ^ indica el inicio, \d un dígito, {5} exactamente cinco veces, $ el final. La cadena '1234' no cumple con {5}.;^: Inicio de línea, \d: Dígito, {5}: Exactamente 5 veces, $: Fin de línea.
^[a-zA-Z]+$;Hola;Esta regex busca una o más letras mayúsculas o minúsculas. La cadena 'Hola' coincide porque todos sus caracteres son letras. ^ indica inicio, [a-zA-Z] cualquier letra, + una o más ocurrencias, $ fin de línea.;^: Inicio de línea, [a-zA-Z]: Cualquier letra (mayúscula o minúscula), +: Una o más veces, $: Fin de línea.
^[a-zA-Z]+$;Hola1;Esta regex busca una o más letras. La cadena 'Hola1' no coincide porque contiene el dígito '1', y la regex solo permite letras [a-zA-Z]. El + aplica al conjunto de letras.;^: Inicio de línea, [a-zA-Z]: Cualquier letra, +: Una o más veces, $: Fin de línea.
^\w+$;usuario_123;Esta regex busca una o más caracteres de palabra (letras, números o guion bajo). La cadena 'usuario_123' coincide. ^ inicio, \w carácter de palabra, + uno o más, $ fin.;^: Inicio de línea, \w: Carácter de palabra (alfanumérico o guion bajo), +: Uno o más, $: Fin de línea.
^\w+$;usuario-123;Esta regex busca uno o más caracteres de palabra. 'usuario-123' no coincide porque \w no incluye guiones medios. El guion medio - rompe la condición \w+.;^: Inicio de línea, \w: Carácter de palabra, +: Uno o más, $: Fin de línea.
\d{2}-\d{2}-\d{4};25-12-2023;Esta regex busca un formato de fecha DD-MM-AAAA. '25-12-2023' coincide. \d{2} dos dígitos, - un guion, \d{4} cuatro dígitos.;\d{2}: Dos dígitos, -: Carácter literal guion, \d{4}: Cuatro dígitos.
\d{2}-\d{2}-\d{4};25/12/2023;No coincide porque la regex espera guiones - como separadores, pero la cadena usa barras /. Falla en los separadores literales -.;\d{2}: Dos dígitos, -: Carácter literal guion, \d{4}: Cuatro dígitos.
^(\(\d{3}\)|\d{3})[-.\s]?\d{3}[-.\s]?\d{4}$;(123) 456-7890;Coincide con formatos de número de teléfono de EE. UU. (\(\d{3}\)|\d{3}) permite (123) o 123. [-.\s]? un separador opcional. \d{3} tres dígitos, otro separador opcional, \d{4} cuatro dígitos. ^ y $ aseguran que toda la cadena coincida.;^: Inicio, (\(\d{3}\)|\d{3}): Grupo captura código área con/sin paréntesis, \d{3}: Tres dígitos, [-.\s]?: Separador opcional (guion, punto o espacio), \d{4}: Cuatro dígitos, $: Fin.
^(\(\d{3}\)|\d{3})[-.\s]?\d{3}[-.\s]?\d{4}$;1234567890;No coincide porque, aunque los números son correctos, faltan los separadores opcionales [-.\s]? o la agrupación del código de área no es como se espera si se omite el separador. Necesita al menos un formato como 123-456-7890 o (123)4567890 (sin espacio después de paréntesis). La ausencia de separadores donde [-.\s]? podría haber estado hace que el patrón falle en su totalidad si no se agrupa como (123). En este caso, la falta del segundo separador es el problema si se interpreta como 123 seguido de 456 sin separador.;^: Inicio, (\(\d{3}\)|\d{3}): Código área, [-.\s]?: Separador opcional, $: Fin.
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$;usuario@ejemplo.com;Busca una dirección de correo electrónico. [a-zA-Z0-9._%+-]+ nombre de usuario, @ literal, [a-zA-Z0-9.-]+ nombre de dominio, \. punto literal, [a-zA-Z]{2,} TLD (ej. com, org). ^ y $ aseguran que es toda la cadena.;^: Inicio, [a-zA-Z0-9._%+-]+: Parte local, @: Literal, [a-zA-Z0-9.-]+: Dominio, \.: Punto literal, [a-zA-Z]{2,}: TLD de al menos 2 letras, $: Fin.
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$;usuario@ejemplo;No coincide porque falta el TLD (la parte después del punto, como .com). La regex requiere \.[a-zA-Z]{2,} al final.;^: Inicio, [...]+@[...]+\.: Estructura base, [a-zA-Z]{2,}: TLD requerido, $: Fin.
^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$;http://www.ejemplo.com/ruta?query=1;Valida una URL. https? http o https. :\/\/ literal. (www\.)? www opcional. [-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6} dominio. \b límite de palabra. ([-a-zA-Z0-9()...]*) ruta y query opcional.;^: Inicio, https?: 'http' o 'https', :\/\/: Literal, (www\.)?: 'www.' opcional, [-a-zA-Z0-9@:%._\+~#=]{1,256}: Nombre de host, \.: Punto literal, [a-zA-Z0-9()]{1,6}: TLD, \b: Límite de palabra, (...)*: Ruta/query opcional, $: Fin.
^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$;ftp://ejemplo.com;No coincide porque la regex espera http o https al inicio, debido a https?. La cadena empieza con ftp.;^: Inicio, https?: 'http' o 'https' requerido, $: Fin.
^\d+(\.\d{1,2})?$;123.45;Busca un número con hasta dos decimales opcionales. \d+ uno o más dígitos. (\.\d{1,2})? grupo opcional para la parte decimal: \. punto literal, \d{1,2} uno o dos dígitos. ^ y $ anclan.;^: Inicio, \d+: Parte entera (uno o más dígitos), (\.\d{1,2})?: Grupo opcional para decimales (\. punto, \d{1,2} uno o dos dígitos), $: Fin.
^\d+(\.\d{1,2})?$;123.456;No coincide porque tiene tres decimales y la regex solo permite hasta dos con \d{1,2} después del punto.;^: Inicio, \d+: Parte entera, (\.\d{1,2})?: Parte decimal opcional, pero si existe, máximo 2 dígitos, $: Fin.
^(?:[01]\d|2[0-3]):[0-5]\d$;14:30;Valida un formato de hora HH:MM (24h). (?:[01]\d|2[0-3]) para HH: [01]\d (00-19) o 2[0-3] (20-23). : literal. [0-5]\d para MM (00-59).;^: Inicio, (?:[01]\d|2[0-3]): Horas (00-23), [01]\d: 00-19, 2[0-3]: 20-23, |: Alternancia (OR), (?:...): Grupo sin captura, :: Literal, [0-5]\d: Minutos (00-59), $: Fin.
^(?:[01]\d|2[0-3]):[0-5]\d$;25:30;No coincide porque la hora '25' es inválida. (?:[01]\d|2[0-3]) solo permite horas hasta 23.;^: Inicio, (?:[01]\d|2[0-3]): Horas (falla aquí para '25'), $: Fin.
^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$;#FF0000;Valida un color hexadecimal. #? # opcional. ([a-fA-F0-9]{6}|[a-fA-F0-9]{3}) 6 dígitos hexadecimales o 3 (forma corta).;^: Inicio, #?: Carácter '#' opcional, ([a-fA-F0-9]{6}|[a-fA-F0-9]{3}): Grupo que captura 6 caracteres hexadecimales O 3 caracteres hexadecimales, [a-fA-F0-9]: Cualquier dígito hexadecimal, {6}: Exactamente 6 veces, {3}: Exactamente 3 veces, |: Alternancia, $: Fin.
^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$;#GG0000;No coincide porque 'G' no es un dígito hexadecimal válido. [a-fA-F0-9] solo permite a-f, A-F, y 0-9.;^: Inicio, #?: '#' opcional, [a-fA-F0-9]: Carácter hexadecimal (falla con 'G'), $: Fin.
.*\.(txt|csv)$;documento.txt;Busca archivos con extensión .txt o .csv. .* cualquier carácter cero o más veces. \. punto literal. (txt|csv) 'txt' o 'csv'. $ final de cadena.;.*: Cualquier carácter (excepto nueva línea) cero o más veces, \.: Punto literal, (txt|csv): Grupo que captura 'txt' O 'csv', $: Fin de línea.
.*\.(txt|csv)$;documento.docx;No coincide porque la extensión 'docx' no está en el grupo (txt|csv).;.*: Cualquier carácter, \.: Punto literal, (txt|csv): Extensiones permitidas (falla aquí), $: Fin de línea.
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$;Abcdef12;Valida una contraseña: al menos 8 caracteres, una minúscula, una mayúscula y un dígito. (?=.*[a-z]) lookahead para minúscula. (?=.*[A-Z]) lookahead para mayúscula. (?=.*\d) lookahead para dígito. [a-zA-Z\d]{8,} que sean 8 o más de esos caracteres.;^: Inicio, (?=.*[a-z]): Lookahead positivo (debe haber una minúscula), (?=.*[A-Z]): Lookahead positivo (debe haber una mayúscula), (?=.*\d): Lookahead positivo (debe haber un dígito), [a-zA-Z\d]{8,}: La contraseña debe tener al menos 8 caracteres alfanuméricos, $: Fin.
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$;abcdef12;No coincide porque falta una letra mayúscula, requerida por (?=.*[A-Z]).;^: Inicio, (?=.*[A-Z]): Lookahead para mayúscula (falla aquí), [a-zA-Z\d]{8,}: Longitud y tipo de caracteres, $: Fin.
^\s*$;;Coincide con una línea vacía o que solo contiene espacios en blanco. ^ inicio, \s* cero o más espacios en blanco (espacios, tabulaciones, etc.), $ fin.;^: Inicio de línea, \s*: Cero o más caracteres de espacio en blanco, $: Fin de línea.
^\s*$;a;No coincide porque la línea contiene 'a', que no es un carácter de espacio en blanco \s.;^: Inicio de línea, \s*: Solo espacios en blanco (falla por 'a'), $: Fin de línea.
^(true|false|yes|no)$;true;Valida respuestas booleanas/afirmativas simples. (true|false|yes|no) una de esas palabras exactas. ^ y $ para coincidencia total.;^: Inicio de línea, (true|false|yes|no): Grupo que coincide con 'true' O 'false' O 'yes' O 'no', |: Alternancia, $: Fin de línea.
^(true|false|yes|no)$;Yes;No coincide por la mayúscula. La regex es sensible a mayúsculas/minúsculas y espera yes en minúscula.;^: Inicio, (true|false|yes|no): Una de las opciones exactas (falla por 'Yes' vs 'yes'), $: Fin.
\b[A-Z][a-z]*\b;Palabra;Busca palabras que comiencen con mayúscula. \b límite de palabra. [A-Z] una mayúscula. [a-z]* cero o más minúsculas. Otro \b.;\b: Límite de palabra, [A-Z]: Una letra mayúscula, [a-z]*: Cero o más letras minúsculas, \b: Límite de palabra.
\b[A-Z][a-z]*\b;palabra;No coincide porque la palabra no empieza con mayúscula, lo que falla la condición [A-Z] al inicio.;\b: Límite de palabra, [A-Z]: Mayúscula inicial (falla aquí), [a-z]*: Minúsculas, \b: Límite de palabra.
^<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>$;<h1>Título</h1>;Busca etiquetas HTML simples con contenido. < literal. ([a-z][a-z0-9]*) captura el nombre de la etiqueta (grupo 1). \b[^>]*> atributos opcionales y cierre de etiqueta inicial. (.*?) captura el contenido (grupo 2, no codicioso). <\/\1> etiqueta de cierre, \1 se refiere al nombre de etiqueta capturado.;^: Inicio, <: Literal '<', ([a-z][a-z0-9]*): Captura el nombre de la etiqueta (grupo 1), \b[^>]*>: Resto de la etiqueta de apertura, (.*?): Contenido (no codicioso), <\/\1>: Etiqueta de cierre correspondiente usando la retroreferencia \1, $: Fin.
^<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>$;<h1>Título</h2>;No coincide porque la etiqueta de cierre </h2> no coincide con la de apertura <h1>. La retroreferencia \1 espera 'h1'.;^: Inicio, <([a-z][a-z0-9]*): Captura 'h1' en \1, (.*?): Contenido, <\/\1>: Espera 'h1', encuentra 'h2' (falla aquí), $: Fin.
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3};192.168.1.1;Busca una dirección IPv4 (forma simple, no valida rangos). Cuatro bloques de 1 a 3 dígitos separados por puntos.;\d{1,3}: Uno a tres dígitos, \.: Punto literal. Se repite cuatro veces para los cuatro octetos.
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3};192.168.1.256;Coincide con la regex, pero no es una IP válida (256 fuera de rango). La regex solo verifica la estructura, no la validez semántica de los números (0-255). Nota: Para el propósito de esta regex, la estructura es correcta y coincidiría. Si la pregunta fuese sobre validez de IP, fallaría. Si la pregunta es puramente sobre si la regex encuentra un patrón, esta regex sí lo encuentra. Para no coincidir estrictamente con la regex (sin considerar validez semántica): 192.168.1; Falta el último octeto.;\d{1,3}: Uno a tres dígitos, \.: Punto literal. La cadena '192.168.1' no tiene el cuarto bloque \.\d{1,3}.
"(.*?)";"Hola Mundo";Extrae texto entre comillas dobles. " literal. (.*?) captura cualquier carácter (grupo 1), cero o más veces, de forma no codiciosa ? para detenerse en la primera comilla de cierre.;": Comilla doble literal de apertura, (.*?): Grupo de captura para cualquier secuencia de caracteres (excepto nueva línea), de forma no codiciosa (? hace que * coincida con la menor cantidad posible de caracteres), ": Comilla doble literal de cierre.
"(.*?)";"Hola Mundo;No coincide porque falta la comilla doble de cierre. El (.*?) buscaría hasta encontrarla, pero llega al final de la cadena sin hacerlo.;": Comilla de apertura, (.*?): Contenido, ": Comilla de cierre (falta aquí).
\b(cat|dog|mouse)\b;I have a dog.;Busca las palabras exactas 'cat', 'dog' o 'mouse'. \b asegura que sean palabras completas, no subcadenas. (cat|dog|mouse) una de las opciones.;\b: Límite de palabra, (cat|dog|mouse): Grupo que coincide con 'cat' O 'dog' O 'mouse', |: Alternancia, \b: Límite de palabra.
\b(cat|dog|mouse)\b;I have a category.;No coincide porque 'category' contiene 'cat' pero no es la palabra completa 'cat'. El \b después de cat fallaría porque e no es un límite de palabra.;\b: Límite de palabra, (cat|dog|mouse): Palabra completa (falla 'category' porque no es 'cat' seguido de \b), \b: Límite de palabra.
^[A-Z0-9]{10}$;AB12CD34EF;Valida un identificador de 10 caracteres alfanuméricos en mayúsculas. ^ inicio, [A-Z0-9] mayúscula o dígito, {10} exactamente 10 veces, $ fin.;^: Inicio de línea, [A-Z0-9]: Cualquier letra mayúscula o dígito, {10}: Exactamente 10 veces, $: Fin de línea.
^[A-Z0-9]{10}$;ab12cd34ef;No coincide porque contiene letras minúsculas y la regex [A-Z0-9] solo permite mayúsculas o dígitos.;^: Inicio, [A-Z0-9]: Mayúscula o dígito (falla con minúsculas), {10}: Exactamente 10, $: Fin.
filename\.([a-zA-Z0-9]+)$;filename.zip;Extrae la extensión de un archivo llamado 'filename'. filename\. literal. ([a-zA-Z0-9]+) captura la extensión (letras y números). $ fin de línea.;filename\.: Literal "filename.", ([a-zA-Z0-9]+): Grupo de captura para la extensión (uno o más caracteres alfanuméricos), $: Fin de línea.
filename\.([a-zA-Z0-9]+)$;myfilename.zip;No coincide porque la regex espera que el nombre del archivo sea exactamente "filename.", no "myfilename.".;filename\.: Literal "filename." (falla aquí), ([a-zA-Z0-9]+): Extensión, $: Fin.
^\s*(\S+)\s+(\S+)\s*$;valor1 valor2;Captura dos palabras separadas por espacios, con espacios opcionales alrededor. ^\s* espacios al inicio. (\S+) primera palabra (no espacios). \s+ uno o más espacios. (\S+) segunda palabra. \s*$ espacios al final.;^: Inicio, \s*: Cero o más espacios, (\S+): Grupo 1, captura uno o más no-espacios (primera palabra), \s+: Uno o más espacios (separador), (\S+): Grupo 2, captura uno o más no-espacios (segunda palabra), \s*: Cero o más espacios, $: Fin.
^\s*(\S+)\s+(\S+)\s*$;valor1;No coincide porque espera dos "palabras" (secuencias de no-espacios) separadas por al menos un espacio. Aquí solo hay una.;^: Inicio, \s*(\S+)\s+: Espera una palabra y un separador (falla por falta de la segunda palabra (\S+)), $: Fin.
(g|gr)[ae]y;gray;Coincide con 'gray' o 'grey'. (g|gr) 'g' o 'gr'. [ae] 'a' o 'e'. y literal.;(g|gr): 'g' o 'gr', [ae]: 'a' o 'e', y: Literal 'y'.
(g|gr)[ae]y;griey;No coincide porque después de 'gr' espera 'a' o 'e' ([ae]), pero encuentra 'i'.;(g|gr): Coincide 'gr', [ae]: Espera 'a' o 'e' (falla con 'i'), y: Literal 'y'.
^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$;00:1A:2B:3C:4D:5E;Valida una dirección MAC. ([0-9A-Fa-f]{2}[:-]){5} cinco bloques de dos dígitos hexadecimales seguidos de : o -. ([0-9A-Fa-f]{2}) el último bloque de dos dígitos hexadecimales. ^ y $ anclan.;^: Inicio, ([0-9A-Fa-f]{2}[:-]){5}: Cinco bloques de dos hexadecimales ([0-9A-Fa-f]{2}) seguidos por un separador ([:-]), ([0-9A-Fa-f]{2}): Último bloque de dos hexadecimales, $: Fin.
^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$;00:1A:2B:3C:4D:5E:6F;No coincide porque hay un bloque de más. La regex espera exactamente 6 bloques (5 con separador y el último sin). {5} más el bloque final hacen 6. Ésta tiene 7.;^: Inicio, (...){5}(...): Estructura de 6 bloques (falla por exceso de bloques), $: Fin.
^\p{Lu};Árbol;Coincide si la cadena comienza con una letra mayúscula Unicode. ^ inicio de cadena. \p{Lu} es una propiedad Unicode para "letra mayúscula".;^: Inicio de línea, \p{Lu}: Cualquier letra mayúscula Unicode.
^\p{Lu};árbol;No coincide porque 'á' en minúscula no es una letra mayúscula Unicode según \p{Lu} (sería \p{Ll} para minúscula).;^: Inicio de línea, \p{Lu}: Letra mayúscula Unicode (falla porque 'á' es minúscula).